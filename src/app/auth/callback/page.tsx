'use client'

import { useEffect, useState, useRef } from 'react'
import { useRouter } from 'next/navigation'
import { CircularProgress, Box, Typography, Alert, Button } from '@mui/material'
import { supabase } from '@/lib/supabase/client'
import { AuthService } from '@/lib/auth/auth-service'

export default function AuthCallbackPage() {
  const router = useRouter()
  const [status, setStatus] = useState<'loading' | 'success' | 'error' | 'timeout'>('loading')
  const [errorMessage, setErrorMessage] = useState<string>('')
  const [countdown, setCountdown] = useState<number>(30)
  const processingRef = useRef<boolean>(false)
  const timeoutRef = useRef<NodeJS.Timeout | null>(null)
  const [isProcessing, setIsProcessing] = useState<boolean>(false)

  const processUser = async (user: any) => {
    if (isProcessing) {
      console.log('‚ö†Ô∏è Already processing user, skipping...')
      return
    }
    
    setIsProcessing(true)
    
    console.log('üîÑ Processing user:', {
      id: user.id,
      email: user.email,
      metadata: user.user_metadata
    })
    
    try {
      // ÎèÑÎ©îÏù∏ Ï†úÌïú ÌôïÏù∏
      if (!user.email?.endsWith('@motionsense.co.kr')) {
        console.log('‚ùå Domain restriction failed:', user.email)
        await supabase.auth.signOut()
        setStatus('error')
        setErrorMessage('Ï†ëÍ∑ºÏù¥ Ï†úÌïúÎêú ÎèÑÎ©îÏù∏ÏûÖÎãàÎã§. @motionsense.co.kr Í≥ÑÏ†ïÏùÑ ÏÇ¨Ïö©Ìï¥Ï£ºÏÑ∏Ïöî.')
        return
      }

      console.log('‚úÖ Domain check passed for:', user.email)

      // ÌîÑÎ°úÌïÑ ÏÉùÏÑ±/ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÎèÑ (Ïó¨Îü¨ Î∞©Î≤ïÏúºÎ°ú ÏãúÎèÑ)
      try {
        console.log('üîÑ Attempting to upsert profile for:', {
          userId: user.id,
          email: user.email,
          fullName: user.user_metadata?.full_name || user.user_metadata?.name
        })
        
        let profile
        
        // Î∞©Î≤ï 1: AuthService ÏÇ¨Ïö©
        try {
          profile = await AuthService.upsertProfile(
            user.id,
            user.email,
            user.user_metadata?.full_name || user.user_metadata?.name || user.email.split('@')[0]
          )
          console.log('‚úÖ Profile upsert successful via AuthService:', profile)
        } catch (authServiceError) {
          console.warn('‚ö†Ô∏è AuthService upsert failed, trying direct database access:', authServiceError)
          
          // Î∞©Î≤ï 2: ÏßÅÏ†ë Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ëÍ∑º (service role ÌÇ§Î°ú)
          try {
            const profileData = {
              id: user.id,
              email: user.email,
              full_name: user.user_metadata?.full_name || user.user_metadata?.name || user.email.split('@')[0],
              role: user.email === 'lewis@motionsense.co.kr' ? 'super_admin' : 'user',
              is_active: true,
              updated_at: new Date().toISOString()
            }
            
            // Í∏∞Ï°¥ ÌîÑÎ°úÌïÑ ÌôïÏù∏
            const { data: existingProfile } = await supabase
              .from('profiles')
              .select('*')
              .eq('id', user.id)
              .single()
            
            if (existingProfile) {
              // ÏóÖÎç∞Ïù¥Ìä∏
              const { data, error } = await supabase
                .from('profiles')
                .update({
                  email: profileData.email,
                  full_name: profileData.full_name,
                  updated_at: profileData.updated_at
                })
                .eq('id', user.id)
                .select()
                .single()
              
              if (error) throw error
              profile = data
            } else {
              // ÏÉàÎ°ú ÏÉùÏÑ±
              const { data, error } = await supabase
                .from('profiles')
                .insert(profileData)
                .select()
                .single()
              
              if (error) throw error
              profile = data
            }
            
            console.log('‚úÖ Profile upsert successful via direct access:', profile)
          } catch (directError) {
            console.error('‚ùå Direct database access also failed:', directError)
            
            // Î∞©Î≤ï 3: ÏûÑÏãúÎ°ú Î°úÍ∑∏Ïù∏ ÏÑ±Í≥µ Ï≤òÎ¶¨ (ÌîÑÎ°úÌïÑ ÏóÜÏù¥)
            console.log('‚ö†Ô∏è Proceeding without profile creation as fallback')
            profile = { id: user.id, email: user.email, role: 'user' }
          }
        }
        
      } catch (profileError) {
        console.error('‚ùå All profile creation methods failed:', {
          error: profileError,
          message: profileError instanceof Error ? profileError.message : profileError,
          stack: profileError instanceof Error ? profileError.stack : undefined
        })
        
        // ÌîÑÎ°úÌïÑ ÏÉùÏÑ±Ïóê Ïã§Ìå®Ìï¥ÎèÑ Î°úÍ∑∏Ïù∏ÏùÄ Ïú†ÏßÄÌïòÍ≥† ÎåÄÏãúÎ≥¥ÎìúÎ°ú Ïù¥Îèô
        console.log('‚ö†Ô∏è Profile creation failed but continuing with login...')
      }

      console.log('‚úÖ Setting success status')
      setStatus('success')
      
      // ÏÑ±Í≥µ Ïãú ÎåÄÏãúÎ≥¥ÎìúÎ°ú Î¶¨ÎîîÎ†âÌä∏
      setTimeout(() => {
        console.log('üîÑ Redirecting to dashboard')
        router.push('/dashboard')
      }, 1000)
      
    } catch (generalError) {
      console.error('‚ùå General error in processUser:', generalError)
      setStatus('error')
      setErrorMessage(`Î°úÍ∑∏Ïù∏ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: ${generalError instanceof Error ? generalError.message : 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò'}`)
    } finally {
      setIsProcessing(false)
    }
  }

  useEffect(() => {
    let timeoutId: NodeJS.Timeout
    let isHandled = false
    
    const handleAuthCallback = async () => {
      if (isHandled) return
      isHandled = true
      
      console.log('Starting auth callback handling...')
      
      try {
        // 30Ï¥à ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï
        timeoutId = setTimeout(() => {
          if (status === 'loading') {
            console.error('‚è∞ Auth callback timeout after 30 seconds')
            setStatus('error')
            setErrorMessage('Î°úÍ∑∏Ïù∏ Ï≤òÎ¶¨ ÏãúÍ∞ÑÏù¥ Ï¥àÍ≥ºÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.')
            setTimeout(() => {
              router.push('/auth/login')
            }, 3000)
          }
        }, 30000)
        
        // URL hash fragmentÏóêÏÑú auth Ï†ïÎ≥¥ Î®ºÏ†Ä ÌôïÏù∏
        if (typeof window !== 'undefined') {
          const hashParams = new URLSearchParams(window.location.hash.substring(1))
          const accessToken = hashParams.get('access_token')
          const refreshToken = hashParams.get('refresh_token')
          const errorParam = hashParams.get('error')
          const errorDescription = hashParams.get('error_description')
          
          console.log('Hash params:', { accessToken: !!accessToken, refreshToken: !!refreshToken, error: errorParam })
          
          if (errorParam) {
            console.error('OAuth error:', errorParam, errorDescription)
            setStatus('error')
            setErrorMessage(errorDescription || errorParam)
            clearTimeout(timeoutId)
            return
          }
          
          if (accessToken && refreshToken) {
            console.log('Setting session with tokens from URL')
            // URLÏóêÏÑú ÌÜ†ÌÅ∞ÏúºÎ°ú ÏÑ∏ÏÖò ÏÑ§Ï†ï
            const { data: sessionData, error: sessionError } = await supabase.auth.setSession({
              access_token: accessToken,
              refresh_token: refreshToken
            })
            
            if (sessionError) {
              console.error('Session set error:', sessionError)
              setStatus('error')
              setErrorMessage(sessionError.message)
              clearTimeout(timeoutId)
              return
            }
            
            if (sessionData.session?.user) {
              console.log('User found in session data:', sessionData.session.user.email)
              await processUser(sessionData.session.user)
              clearTimeout(timeoutId)
              return
            }
          }
        }

        // Í∏∞Ï°¥ ÏÑ∏ÏÖò ÌôïÏù∏
        console.log('Checking existing session...')
        const { data, error } = await supabase.auth.getSession()
        
        if (error) {
          console.error('Get session error:', error)
          setStatus('error')
          setErrorMessage(error.message)
          clearTimeout(timeoutId)
          return
        }

        if (data.session?.user) {
          console.log('User found in existing session:', data.session.user.email)
          await processUser(data.session.user)
          clearTimeout(timeoutId)
        } else {
          console.log('No session found')
          setStatus('error')
          setErrorMessage('Ïù∏Ï¶ù Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.')
          clearTimeout(timeoutId)
          
          // 3Ï¥à ÌõÑ Î°úÍ∑∏Ïù∏ ÌéòÏù¥ÏßÄÎ°ú Î¶¨ÎîîÎ†âÌä∏
          setTimeout(() => {
            router.push('/auth/login')
          }, 3000)
        }
      } catch (error) {
        console.error('Auth callback processing error:', error)
        setStatus('error')
        setErrorMessage('Î°úÍ∑∏Ïù∏ Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.')
        clearTimeout(timeoutId)
      }
    }

    handleAuthCallback()
    
    // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú ÌÉÄÏûÑÏïÑÏõÉ Ï†ïÎ¶¨
    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId)
      }
    }
  }, [router, status])

  if (status === 'error') {
    return (
      <Box
        display="flex"
        flexDirection="column"
        justifyContent="center"
        alignItems="center"
        minHeight="100vh"
        gap={2}
        px={2}
      >
        <Alert severity="error" sx={{ maxWidth: 400 }}>
          <Typography variant="h6" gutterBottom>
            Î°úÍ∑∏Ïù∏ Ïã§Ìå®
          </Typography>
          <Typography variant="body2">
            {errorMessage}
          </Typography>
        </Alert>
        <Typography 
          variant="body2" 
          color="primary" 
          sx={{ cursor: 'pointer' }}
          onClick={() => router.push('/auth/login')}
        >
          Îã§Ïãú Î°úÍ∑∏Ïù∏ÌïòÍ∏∞
        </Typography>
      </Box>
    )
  }

  return (
    <Box
      display="flex"
      flexDirection="column"
      justifyContent="center"
      alignItems="center"
      minHeight="100vh"
      gap={2}
    >
      <CircularProgress />
      <Typography variant="body1">
        {status === 'success' ? 'Î°úÍ∑∏Ïù∏ ÏôÑÎ£å! ÎåÄÏãúÎ≥¥ÎìúÎ°ú Ïù¥Îèô Ï§ë...' : 'Î°úÍ∑∏Ïù∏ Ï≤òÎ¶¨ Ï§ë...'}
      </Typography>
    </Box>
  )
}